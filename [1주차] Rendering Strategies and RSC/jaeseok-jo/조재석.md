# 1주차: 웹 렌더링 전략 및 React Server Component의 이해

## Next에서의 웹 렌더링 전략 요약

- **Static Site Generation (SSG)**
  - 빌드 할 때 HTML이 생성되는 방식 (사전에 렌더링이 됨)
  - 생성된 HTML은 요청이 있을 때마다 별도의 작업 없이 HTML을 그대로 사용할 수 있음 -> 이름 그대로 정적인 페이지(블로그)에 적합
    - 추가적인 로딩이 없기 때문에 페이지 성능 면에서 우수함 -> SEO가 우선시되는 사이트에 적합
- **Server-Side Rendering (SSR)**
  - SSG와 동일하게 사전에 렌더링 됨 -> SEO에 좋음
  - SSG와 달리 SSR은 빌드 시점이 아닌 요청 시에 HTML이 생성됨 -> 동적인 페이지에 적합
- **Incremental Static Regeneration (ISR)**
  - 필요에 따라 SSR 또는 SSG를 사용하는 전략
  - 상황에 맞춰 적절한 전략을 취하며 페이지를 불러올 수 있기 때문에 다량(수백만)의 정적 페이지를 생성하고 유지할 수 있음
- **Client Side Rendering (CSR)**
  - 자바스크립트를 이용해 브라우저에서 웹사이트를 렌더링 하는 방식
  - 초반에 가지고 온 HTML의 경우(브라우저에서 렌더링을 거치지 않은) 빈 HTML임 -> 크롤러가 데이터를 확인하기 어려움 -> SEO가 좋지 않음
  - 데이터가 많은 대시보드, 계정 페이지 등에 적합

<hr >

### Static Site Generation (SSG)

빌드 시 정적 HTML을 생성하는 방식

- **Page Route**

  - `getStaticProps`를 통해 정적 페이지를 생성할 수 있음

    ```typescript
    // getStaticProps()를 통해 전달받은 post 데이터로 정적 페이지 생성
    export default function Posts({ posts }) {
      return (
        <div>
          <h1>포스트 목록</h1>
          <ul>
            {posts.map((post) => (
              <li key={post.id}>{post.title}</li>
            ))}
          </ul>
        </div>
      );
    }

    // 빌드 할 때 데이터를 가지고 와서 props를 가지고 옴
    export async function getStaticProps() {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      const posts = await res.json();

      return {
        props: { posts },
      };
    }
    ```

  - `page/[id]`와 같은 동적 경로의 경우 `getStaticPaths`를 이용해서 일부 id에 대해서 정적 페이지를 생성할 수 있음
  - 정적 페이지로 생성된 id로 접속하는 경우 정적 페이지를 나타내고 아닌 경우 런타임 시 페이지 생성

    ```typescript
    import { useRouter } from "next/router";

    export default function Post({ post }) {
      const router = useRouter();

      //fallback이 true이기 때문에 로딩 상태를 나타낼 수 있음
      if (router.isFallback) {
        return <div>Loading...</div>;
      }

      return (
        <div>
          <h1>{post.title}</h1>
          <p>{post.body}</p>
        </div>
      );
    }

    // 미리 정적으로 생성할 페이지의 경로를 결정
    export async function getStaticPaths() {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      const posts = await res.json();

      const paths = posts.map((post) => ({
        params: { id: post.id.toString() },
      }));

      // fallback은 paths(id) 이외의 값이 오는 경우 404 처리(falfe)되는지 런타임 때 가지고 생성하는지 나타내는 값
      return { paths, fallback: true };
    }

    export async function getStaticProps({ params }) {
      // path 이외의 값이 전달되는 경우 getStaticProps에서 설정한 fetch 함수로 값을 런타임 때 가지고 옴
      const res = await fetch(
        `https://jsonplaceholder.typicode.com/posts/${params.id}`
      );
      const post = await res.json();

      return { props: { post } };
    }
    ```

- **App Route**

  - App Router에서 기본적으로 모든 컴포넌트는 서버 컴포넌트로 렌더링 됨
  - 기본적으로 정적 데이터를 사용하는 경우 자동으로 SSG로 동작

    ```typescript
    export default async function PostsPage() {
      // 기본적으로 SSG 적용됨 (fetch 결과는 빌드 시 캐싱)
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      const posts = await res.json();

      return (
        <div>
          <h1>Posts (SSG)</h1>
          <ul>
            {posts.map((post) => (
              <li key={post.id}>{post.title}</li>
            ))}
          </ul>
        </div>
      );
    }
    ```

  - Page Router의 `getStaticPaths`와 같이 동적 라우팅에서 정적 페이지를 생성하기 위해선 `generateStaticParams`

    ```typescript
    // generateStaticParams를 통해 반환된 경로는 빌드 시점에 정적으로 HTML 페이지로 미리 생성됨
    // 이외의 경로는 요청 시 동적으로 렌더링
    export async function generateStaticParams() {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");
      const posts = await res.json();

      return posts.map((post) => ({ id: post.id.toString() }));
    }

    export default async function PostPage({ params }) {
      const res = await fetch(
        `https://jsonplaceholder.typicode.com/posts/${params.id}`
      );
      const post = await res.json();

      return (
        <div>
          <h1>{post.title}</h1>
          <p>{post.body}</p>
        </div>
      );
    }
    ```

- **장점**
  - 빠른 속도 -> 이미 생성된 HTML을 띄우기만 하기 때문에 성능적으로 우수함
  - SEO 최적화 -> 성능적으로 우수하고 미리 HTML이 생성됐기 때문에 크롤러가 쉽게 읽고 인덱싱 할 수 있음
  - 서버 부하 감소 -> 이미 생성된 HTML을 반환하는 역할만 서버가 수행하기 떄문에 추가적인 계산이나 처리가 적음
- **단점**
  - 실시간 업데이트가 어려움 -> 미리 빌드한 데이터로 제공하기 때문에 오래된 데이터를 확인할 수 있음
    - 동적 콘텐츠에 부적합
  - 빌드 시간이 오래 걸림 -> 페이지 수나 데이터 양이 늘어나는 경우 빌드시간이 무자비하게 늘어남

<hr >
